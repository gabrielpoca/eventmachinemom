\section{Introdução Teórica}

Esta secção serve de introdução teórica aos conceitos utilizados ao longo do relatório. O objectivo é relembrar o fundamental e establecer a terminologia a utilizar no desenvolvimento do relatório.

% ---------------------- Message Oriented Middleware

\subsection{Message oriented middleware (MOM)}
\label{sec:mom}
Entende-se por \textit{message oriented middleware} (MOM) como um método de comunicação entre componentes de sistemas distribuídos.

\begin{description}
  \item[Assincrono] \hfill \\
  	Permite que um cliente não bloqueie enquanto espera por resposta.
  \item[Second]
  \item[Third] The third etc \ldots
\end{description}

No contexto deste relatório entede-se por MOM como uma camada de comunicação que permite a várias aplicações comunicar ignorando as especificidades de cada uma.

\input{mom}

% ---------------------- Websockets

\subsection{Introdução a websockets}

A conceção inicial da web considerou apenas a comunicação cliente-servidor num sentido apenas. Actualmente o HTML5 procura corrigir esta entrave, contudo ainda muitos projectos utilizam \textit{long-polling} para simular a comunicação cliente-servidor.

Actualmente os browsers são actualizados regularmente e suportam a API de comunicação do HTML5.
\subsubsection{\textit{Long pulling}}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{longpolling-architecture.png}
\caption{Esquema de \textit{long pulling}}
\label{fig:long_pulling}
\end{figure}

Um cliente (browser) envia por HTTP um pedido para o servidor com o identificador do utilizador (por exemplo) e do estado actual. No servidor é criado um processo que repetidamente verifica na base de dados se existe um estado novo. Quando existe um novo estado o cliente recebe e envia um novo pedido ao servidor.

\subsubsection{\textit{Server-Sent Events}}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{sse-architecture.png}
\caption{Esquema de \textit{server-sent events}}
\label{fig:sse-architecture}
\end{figure}

Um cliente (browser) faz um pedido ao servidor. O servidor responde com o último estado na base de dados. O cliente recebe a resposta e em três segundos (por exemplo) envia um novo pedido.

\subsubsection{Websockets}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{websocket-architecture.png}
\caption{Esquema de \textit{websockets}}
\label{fig:websockets-architecture}
\end{figure}

Um cliente notifica o servidor de websockets de um evento. O servidor imediamente notifica todos os clientes ativos do evento. Este processo pode envolver filtros e subscrição de eventos.

\input{websockets}

\subsection{Ruby}
\label{sec:ruby}

Ruby é uma linguagem de programação intrepertada com suporte para diferentes paradigmas (funcional, orientado a objectos e imperativo). Desde o lançamento em 1995 Ruby tem crescido em comunidade e potencial. O seu criador, Yukihiro Matsumoto, pretendia uma linguagem que qualquer programador pudesse aperciar:

\begingroup
\leftskip4em
\rightskip\leftskip
``Ruby is simple in appearance, but is very complex inside, just like our human body.'' \cite{matz}
\par
\endgroup

Ruby encontra-se actualmente na versão 2.0.0-p195 no entanto o projecto foi desenvolvido na versão \textbf{2.0.0p0}.

\subsubsection{\textit{Global Interpreter Lock}}
\label{sec:gil}

Existem diversos intrepertadores para Ruby sendo os mais importantes \textbf{Matz's Ruby Interpreter (MRI)}, em homenagem ao criador, e \textbf{JRuby}, implementado no topo da Java Virtual Machine.
A diferença mais relevante entre ambos para este projecto é o \textit{Global Interpreter Lock} (GIL) que existe no MRI. O GIL é uma camada responsável por proteger o intrepertador contra código \textit{non thread-safe}.

A figura~\ref{fig:ruby-gil} apresenta uma comparação entre três versões do Ruby. Na versão 1.8 o intrepertador Ruby possuí apenas uma thread do sistema para execussão. Já na versão 1.9, e também na versão 2 ainda que não seja visível na imagem, várias threads do sistema são alocadas ao intrepertador, o que parece prometer paralelismo de execussão. No entanto em ambos os casos existe a camada do GIL que protegendo contra a execussão de código \textit{non thread-safe} permite que apenas uma thread seja executada de cada vez pelo processador, ou seja, ambas as versões do Ruby correm num core do CPU apenas.
Por outro lado a implementação em JRuby não contém a camada GIL o que abre as portas ao paralelismo das aplicações em Ruby.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{xruby_gil.png}
\caption{\textit{Global Interpreter Lock}}
\label{fig:ruby-gil}
\end{figure}

Parecendo um cenário desvantajoso para o MRI é de notar que existem soluções para contornar este problema. Se se pensar em processos em vez de threads por procurar-se outros meios de repartir trabalho. Decompondo a aplicação e adicionando meios de comunicação entre processos (Starling, RabbitMQ, outros) consegue-se que multiplos processos da mesma aplicação executem concurrentemente.
