\section{Servidor}

Nesta secção não se pretende analisar o servidor mas os broker e as respectivas componentes, descrevendo as respectivas responsabilidades e comportamento.
Relembra-se que o servidor é constituído por um numero aleatório de brokers e uma base de dados.

Os brokers são instâncias de uma aplicação desenvolvida em Ruby. Cada instância difere apenas nos endereços de comunicação: um para comunicação com clientes e outro para comunicação com os restantes brokers.
Sendo que cada broker executa num processo Ruby justifica-se que na mesma máquina se executem diversos brokers de forma a tirar partido de paralelismo de processamento (ver secção~\ref{sec:ruby}).
Note-se que cada broker executa numa thread apenas uma vez que a aplicação executa no no paradigma orientado a eventos fazendo uso da ferramenta EventMachine (ver secção~\ref{sec:eventmachine}).

Toda a comunicação do servidor funciona sobre websockets. Tanto com clientes como entre os brokers (à exceção evidente da comunicação com a base de dados). A decisão de utilizar websockets para comunicação entre os brokers é questionável, outros protocolos como o Advanced Message Queuing Protocol\footnote{http://en.wikipedia.org/wiki/Advanced\_Message\_Queuing\_Protocol} são uma solução eventualmente mais estável uma vez que é adotado por imensas ferramentas relacionadas.
Contudo o único requisito quanto à comunicação entre brokers neste projeto passa por garantir comunicação não bloqueante, como tal websockets é uma tecnologia que se utiliza na comunicação com clientes e não existe impedimento ao uso na comunicação entre brokers. Motivos que revelem outros protocolos como mais adequados podem surgir em situações que se entenda que é necessário diminuir tempos de comunicação ou algo semelhante.

\subsection{Componentes}
Como se entende da introdução a esta secção cada broker garante dois serviços de websockets:

\begin{itemize}
\item um para comunicação com os clientes. Será identificado ao longo do relatório como \textbf{serviço de comunicação}).
\item um para comunicação com os restantes brokers. Será identificado ao longo do relatório como \textbf{serviço de sincronização}).
\end{itemize}

Ainda que execute dois serviços de websockets que atendem em portas diferentes os mesmos são servidor pela mesma thread num ambiente orientado a eventos. Esta decisão advém do facto de que utilizado o MRI não existe concorrência real entre threads (a justificação deste facto está na secção~\ref{sec:gil}).

\subsubsection{Serviço de comunicação}

Esta secção pretende apresentar a interação entre um cliente e o servidor.
O serviço de comunicação com os clientes responde aos seguintes eventos de um cliente:

\begin{enumerate}
\item \textbf{nova ligação}. O servidor armazena a ligação e devolve um identificador único ao cliente.
\item \textbf{subscrição de canal}. O servidor procura o canal ou cria um novo e devolve ao cliente uma mensagem conforme sucedido.
\item \textbf{cancelamento de canal}. O servidor remove a subscrição do cliente a um canal.
\item \textbf{difusão de mensagens}. O servidor entrega uma mensagem nos canais pretendidos.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{server_client.png}
\caption{\textit{Ciclo de vida de um cliente.}}
\label{fig:server-client}
\end{figure}

A figura~\ref{fig:server-client} contém um diagrama de sequência que apresenta o básico da interação entre um cliente e o servidor (entenda-se por servidor como um broker do servidor).
Um cliente começa por estabelecer ligação a um dos brokers do servidor. Assim que a ligação é estabelecida o broker devolve um identificador único ao cliente. Esta etapa está identificada no bloco um na figura~\ref{fig:server-client}. Depois esta etapa inicial são três os cenários possíveis servidor

\begin{itemize}
\item
\textbf{O cliente envia uma mensagem}

O cliente envia uma mensagem ao broker (etapa 2 da figura~\ref{fig:server-client}). A mensagem é devolvida ao cliente no processo de broadcast do servidor.

\item
\textbf{O servidor faz broadcast de uma mensagem}

O servidor envia uma mensagem no processo de broadcast de mensagens de outros clientes (etapa 3 da figura~\ref{fig:server-client}).

\item
\textbf{O cliente termina a ligação}

O cliente termina a ligação com o servidor (etapa 4 da figura~\ref{fig:server-client}).
\end{itemize}


%-- Sincronização 

\subsubsection{Serviço de sincronização}
De modo a melhor explicar o comportamento desencadeado nas diferentes situações as próximas listas contém uma enumeração sequencial dos eventos no servidor para diferentes situações.

\hl{}

\textbf{Um broker inicía}\\
Assumindo que já existem brokers ligados a próxima lista descreve o comportamento desencadeado no servidor com o iniciar do novo broker.

\begin{enumerate}
\item O novo broker inicía o serviço de sincronização.
\item O novo broker regista o endereço na base de dados.
\item O novo broker establece uma ligação a todos os restantes com base na lista de brokers activos que se encontra na base de dados.
\item O novo broker envia uma mensagem de actualização a todos os brokers.
\item Todos os brokers que recebem mensagem de actualização vão à base de dados verificar as divergências com a nova lista de brokers activos, removendo ou establecendo ligações consoante necessário.
\item O novo broker carrega os canais com persistência a partir da base de dados. Os canais sem persistência não é necessário carregar.
\item O novo broker inicía o serviço de comunicação com os clientes.
\end{enumerate}

No final deste processo o broker encontra-se operacional.

\hl{}

\textbf{Um broker desliga}\\
Um broker pode desligar-se por falha ou porque simplesmente foi desligado pelo utilizador. Consoante o caso o comportamento varia.

Quando um broker é desligado pelo utilizador a deteção de falha é automática uma vez que os restantes brokers activos são informados no canal de comunicação.

\begin{enumerate}
\item Um broker é desligado manualmente.
\item Os restantes brokers removem o broker da lista local de brokers actvos.
\item Um broker actualiza na base de dados o estado do broker que se desligou marcado como inactivo.
\end{enumerate}

O servidor reconhece uma falha num broker quando os restantes tentam enviar-lhe uma mensagem.

\begin{enumerate}
\item Um broker deixa de responder (falha).
\item Um outro broker tenta difunidr uma mensagem ao broker que falhou e recebe um erro.
\item O broker que recebe um erro remove o broker que falhou da sua lista local e marca o broker como inactivo na base de dados.
\item O broker que recebe um erro informa os restantes da actualização na lista de brokers activos.
\item Todos os brokers que recebem mensagem de actualização vão à base de dados verificar as divergências com a nova lista de brokers activos, removendo ou establecendo ligações consoante necessário.
\end{enumerate}


\subsubsection{Identificação de utilizadores}
Existem diversos métodos para fornecer identificadores únicos aos clientes. Num caso de um sistema ditribuído poderia eleger-se um broker como responsável pelo processo, ou adoptar um protocolo que permitisse aos brokers chegar a um acordo aquando a atribuição de um identificador. A método adoptado consiste em passar a responsabilidade para a base de dados. Esta mantém uma \textit{sequence} a partir da qual devolve identificadores aos brokers. O controlo de concorrência é responsabilidade da base de dados. Deste modo reduz-se o numero de mensagens trocadas entre os brokers e diminui-se a complexidade de implementação fazendo uso de uma ferramenta que é de qualquer modo necessária para o servidor.

É de realçar que este identificador não apresenta relevância para o servidor, serve apenas para o caso de os clientes pretenderem identificar-se nas mensagens.
